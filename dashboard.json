{
  "metadata": {
    "totalProblems": 4,
    "lastUpdated": "2025-10-07T18:03:53.887Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 3,
        "Easy": 2,
        "Medium": 0,
        "Hard": 1
      },
      "Hackerrank": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "gfg-easy-missing-in-array",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Missing in Array",
      "language": "java",
      "files": {
        "code": "class Solution {\n    int missingNum(int arr[]) {\n        int n = arr.length + 1;\n    int xor = 0;\n    // XOR all numbers from 1 to n\n    for (int i = 1; i <= n; i++) {\n        xor ^= i;\n    }\n    // XOR all elements in array\n    for (int num : arr) {\n        xor ^= num;\n    }\n    return xor;\n    }\n}",
        "readme": "Arrays,Searching,Bit_Magic,Data_Structures,Algorithms\n\nMissing in Array\nDifficulty: EasyAccuracy: 29.59%Submissions: 1.5MPoints: 2Average Time: 15m\n\nYou are given an array arr[] of size n - 1 that contains distinct integers in the range from 1 to n (inclusive). This array represents a permutation of the integers from 1 to n with one element missing. Your task is to identify and return the missing element.\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 5]\nOutput: 4\nExplanation: All the numbers from 1 to 5 are present except 4.\n\nInput: arr[] = [8, 2, 4, 5, 3, 7, 1]\nOutput: 6\nExplanation: All the numbers from 1 to 8 are present except 6.\nInput: arr[] = [1]\nOutput: 2\nExplanation: Only 1 is present so the missing element is 2.\n\n\nConstraints:\n1 ≤ arr.size() ≤ 106\n1 ≤ arr[i] ≤ arr.size() + 1\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles\nReport An Issue\nIf you are facing any issue on this page. Please let us know.",
        "notes": "Missing in Array\n\n          - Summary: The code utilizes an array to store input numbers. It leverages the bitwise XOR operator to find the missing number. First, it XORs all numbers from 1 to n (n being the expected array length including the missing number). Then, it XORs the result with all elements in the input array. The final XOR result is the missing number because XORing a number with itself results in 0, canceling out existing numbers and leaving only the missing one.\n\n          - Time Complexity: O(n) because the code iterates through the input array once and through a range of numbers from 1 to n (where n is the length of the array plus 1) once. Both loops are linear in terms of the input size.\n          - Space Complexity: O(1) because the code uses a constant amount of extra space regardless of the input array size. The variables 'n', 'xor', and 'i' occupy constant space."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-09-02T16:20:13.000Z"
    },
    {
      "id": "leetcode-easy-merge-two-sorted-lists",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Merge Two Sorted Lists",
      "language": "cpp",
      "files": {
        "code": "class Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* tail = &dummy;\n\n        // Incorrect comparison: use < instead of <= to break stable ordering\n        while (list1 && list2) {\n            if (list1->val < list2->val) {  // wrong: should be <= for stable merge\n                tail->next = list1;\n                list1 = list1->next;\n            } else {\n                tail->next = list2;\n                list2 = list2->next;\n            }\n            tail = tail->next;\n        }\n\n        tail->next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};",
        "readme": "LinkedListRecursion\n\nYou are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.\n\n \nExample 1:\n\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\n\nExample 2:\n\nInput: list1 = [], list2 = []\nOutput: []\n\n\nExample 3:\n\nInput: list1 = [], list2 = [0]\nOutput: [0]\n\n\n \nConstraints:\n\n\n\tThe number of nodes in both lists is in the range [0, 50].\n\t-100 <= Node.val <= 100\n\tBoth list1 and list2 are sorted in non-decreasing order.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-07T18:03:28.000Z"
    },
    {
      "id": "leetcode-easy-remove-element",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Remove Element",
      "language": "cpp",
      "files": {
        "code": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int index = 0;\n        for(int i = 0; i< nums.size(); i++){\n            if(nums[i] != val){\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        return index;\n    }\n};",
        "readme": "ArrayTwoPointers\n\nGiven an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\n\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\n\n\n\tChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\n\tReturn k.\n\n\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n\nIf all assertions pass, then your solution will be accepted.\n\n \nExample 1:\n\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\nExample 2:\n\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\n \nConstraints:\n\n\n\t0 <= nums.length <= 100\n\t0 <= nums[i] <= 50\n\t0 <= val <= 100",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-07T17:51:43.000Z"
    },
    {
      "id": "leetcode-hard-median-of-two-sorted-arrays",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Median of Two Sorted Arrays",
      "language": "cpp",
      "files": {
        "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        // Get the sizes of both input arrays.\n        int n = nums1.size();\n        int m = nums2.size();\n\n        // Merge the arrays into a single sorted array.\n        vector<int> merged;\n        for (int i = 0; i < n; i++) {\n            merged.push_back(nums1[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            merged.push_back(nums2[i]);\n        }\n\n        // Sort the merged array.\n        sort(merged.begin(), merged.end());\n\n        // Calculate the total number of elements in the merged array.\n        int total = merged.size();\n\n        if (total % 2 == 1) {\n            // If the total number of elements is odd, return the middle element as the median.\n            return static_cast<double>(merged[total / 2]);\n        } else {\n            // If the total number of elements is even, calculate the average of the two middle elements as the median.\n            int middle1 = merged[total / 2 - 1];\n            int middle2 = merged[total / 2];\n            return (static_cast<double>(middle1) + static_cast<double>(middle2)) / 2.0;\n        }\n    }\n};",
        "readme": "ArrayBinarySearchDivideandConquer\n\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \nConstraints:\n\n\n\tnums1.length == m\n\tnums2.length == n\n\t0 <= m <= 1000\n\t0 <= n <= 1000\n\t1 <= m + n <= 2000\n\t-106 <= nums1[i], nums2[i] <= 106",
        "notes": "Median of Two Sorted Arrays\n\n          - Summary: The code uses vectors (dynamic arrays) to store and manipulate the input arrays and a merged array.  It first merges the two input sorted arrays into a single vector, then sorts the merged vector. Finally, it determines the median based on whether the total number of elements is odd or even, returning the middle element or the average of the two middle elements, respectively.\n\n          - Time Complexity: O(m+n+log(m+n)). The merging of the two arrays takes O(m+n) time. Sorting the merged array using `std::sort` takes O( (m+n)log(m+n) ) time in the average and worst cases.  The remaining operations take constant time.\n          - Space Complexity: O(m+n). The space complexity is dominated by the `merged` vector which stores all elements from both input arrays. The size of this vector is linear with respect to the sum of sizes of the input arrays (m+n)."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-09-02T16:07:08.000Z"
    }
  ]
}